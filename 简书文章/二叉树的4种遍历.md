* [å¸¸ç”¨çš„æ’åº](https://www.jianshu.com/p/8da36058e1ab)
* [äºŒå‰æ ‘çš„4ç§éå†](https://www.jianshu.com/p/ccac29fad2f9)
* [å…«çš‡åé—®é¢˜](https://www.jianshu.com/p/deb028537af2)

## æ ‘
> å®šä¹‰:äºŒå‰æ ‘æ˜¯nï¼ˆn>0ï¼‰ä¸ªèŠ‚ç‚¹çš„æœ‰é™é›†åˆï¼Œè¯¥é›†åˆæˆ–è€…ä¸ºç©ºé›†ï¼ˆç©ºäºŒå‰æ ‘ï¼‰,æˆ–è€…ç”±ä¸€ä¸ªæ ¹èŠ‚ç‚¹å’Œä¸¤æ£µäº’ä¸ç›¸äº¤åˆ†åˆ«ç§°ä¸ºæ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘å’Œå³å­æ ‘çš„äºŒå‰æ ‘ç»„æˆã€‚

*** æ³¨æ„ï¼š***
- n>0 æ—¶èŠ‚ç‚¹æ˜¯å”¯ä¸€çš„ï¼Œä¸å¯èƒ½å­˜åœ¨å¤šä¸ªèŠ‚ç‚¹ï¼Œåˆ«å’Œç°å®ä¸­çš„æ ‘æœ¨æ··åœ¨ä¸€èµ·ã€‚
- m>0 æ—¶ï¼Œå­æ ‘çš„ä¸ªæ•°æ²¡æœ‰é™åˆ¶ï¼Œä½†æ˜¯ä¸€å®šæ˜¯ä¸äº¤äº’çš„ã€‚

## æ ‘çš„å››ç§éå†
> éå†ï¼šäºŒå‰æ ‘çš„éå†æ˜¯æŒ‡ä»æ ¹èŠ‚ç‚¹å‡ºå‘,æŒ‰ç…§æŸç§æ¬¡åºä¾æ¬¡è®¿é—®äºŒå‰æ ‘ä¸­æ‰€æœ‰èŠ‚ç‚¹,ä½¿å¾—æ¯ä¸ªèŠ‚ç‚¹è¢«è®¿é—®ä¾æ¬¡ä¸”è¢«è®¿é—®ä¾æ¬¡ã€‚

- å‰åºéå†
- ä¸­åºéå†
- ååºéå†
- å±‚åºéå†

### å‰åºéå†
>å®šä¹‰ï¼šè§„åˆ™æ˜¯è‹¥äºŒå‰æ ‘ä¸ºç©ºï¼Œåˆ™ç©ºæ“ä½œè¿”å›ã€‚ å¦åˆ™å…ˆè®¿é—®è·ŸèŠ‚ç‚¹ï¼Œç„¶åå‰åºéå†å·¦å­æ ‘ï¼Œå†éå†å³å­æ ‘ã€‚
ä¼˜å…ˆçº§ï¼šæ ¹->å·¦->å³

### ä¸­åºéå†
>å®šä¹‰ï¼šè§„åˆ™æ˜¯æ ‘è‹¥ä¸ºç©ºï¼Œæ“ä½œè¿”å›ï¼Œå¦åˆ™ä»æ ¹èŠ‚ç‚¹å¼€å§‹ï¼Œä¸­åºéå†(æ³¨æ„å¹¶ä¸æ˜¯è®¿é—®æ ¹èŠ‚ç‚¹)æ ¹èŠ‚ç‚¹çš„å·¦å­æ ‘ï¼Œç„¶åè®¿é—®æ ¹èŠ‚ç‚¹ï¼Œæœ€åä¸­åºéå†å³å­æ ‘ã€‚
ä¼˜å…ˆçº§ï¼šå·¦->æ ¹->å³

### ååºéå†
>å®šä¹‰ï¼šè§„åˆ™æ˜¯è‹¥æ ‘ç©º,æ“ä½œè¿”å›ï¼Œå¦åˆ™æ˜¯ä»å·¦åˆ°å³å…ˆå¶å­åèŠ‚ç‚¹çš„æ–¹å¼éå†è®¿é—®å·¦å³å­æ ‘ï¼Œæœ€åæ˜¯è®¿é—®è·ŸèŠ‚ç‚¹ã€‚
ä¼˜å…ˆçº§ï¼šå·¦->å³->æ ¹

### å±‚åºéå†
>å®šä¹‰ï¼šè§„åˆ™æ˜¯è‹¥æ ‘ç©º,æ“ä½œè¿”å›ï¼Œå¦åˆ™æ˜¯ä»æ ‘çš„ç¬¬ä¸€å±‚ï¼Œä¹Ÿå°±æ˜¯ä»æ ¹èŠ‚ç‚¹å¼€å§‹è®¿é—®ï¼Œä»ä¸Šè€Œä¸‹é€å±‚éå†ï¼Œåœ¨åŒä¸€å±‚ä¸­ï¼Œä»å·¦åˆ°å³çš„é¡ºåºå¯¹èŠ‚ç‚¹é€ä¸ªè®¿é—®ã€‚ä¼˜å…ˆçº§ï¼šé¡¶éƒ¨åˆ°åº•éƒ¨çš„æ‰€æœ‰èŠ‚ç‚¹

## ä»£ç ç¤ºä¾‹4ä¸­éå†

```


è¿™å››ç§éå†ç¤ºä¾‹ï¼š   

             A
          /    \
        B        C
      /  \      /  \ 
     D    E     F   G  
 å±‚åºéå†ç»“æœæ˜¯:  ABCDEFG
 å‰åºéå†ç»“æœæ˜¯:  ABDECFG
 ä¸­åºéå†ç»“æœæ˜¯:  DBEAFCG
 ååºéå†ç»“æœæ˜¯:  DEBFGCA



//èŠ‚ç‚¹å¯¹è±¡
@interface Node : NSObject

@property (nonatomic) NSInteger data;//å­˜å‚¨çš„æ•°æ®

@property (nonatomic) Node * leftNode; //å·¦èŠ‚ç‚¹

@property (nonatomic) Node * rightNode; //å³èŠ‚ç‚¹

@end

@implementation Node

@end
```
æ¯ä¸€ç§éå†å…¶å®éƒ½æ˜¯é€’å½’ï¼Œåªæ˜¯é€’å½’çš„æ—¶å€™ï¼Œå¤„ç†æ•°æ®çš„ä»£ç æ—¶æœºä¸ä¸€æ ·ã€‚
```

//å‰åº éå†
/*
 è§„åˆ™æ˜¯è‹¥äºŒå‰æ ‘ä¸ºç©ºï¼Œåˆ™ç©ºæ“ä½œè¿”å›ã€‚ å¦åˆ™å…ˆè®¿é—®è·ŸèŠ‚ç‚¹ï¼Œç„¶åå‰åºéå†å·¦å­æ ‘ï¼Œå†éå†å³å­æ ‘ã€‚è·Ÿ->å·¦->å³
 
 */
-(void)printNode:(Node *)node{
    if (node == nil) {
        return;
    }
    NSLog(@"%ld",node.data);
    [self printNode:node.leftNode];
    [self printNode:node.rightNode];
}
// ä¸­åºéå†   ä» å·¦å­æ ‘ã€å·¦->æ ¹->å³ã€‘
-(void)printCenterNode:(Node *)node{
    if (node == nil) {
        return;
    }
    [self printCenterNode:node.leftNode];
     NSLog(@"%ld",node.data);
    [self printCenterNode:node.rightNode];
}

// ååºéå†   ä» å·¦å­æ ‘ã€å·¦->å³->æ ¹ã€‘
-(void)print2Node:(Node *)node{
    if (node == nil) {
        return;
    }
    [self print2Node:node.leftNode];
    [self print2Node:node.rightNode];
    NSLog(@"%ld",node.data);//èŠ‚ç‚¹æ•°æ®å¯ä»¥è¿›è¡Œå…¶ä»–æ“ä½œ
}

//å±‚åºéå† è¿­ä»£ç‰ˆæœ¬
    func trav_L_R(tree:Tree) -> Void {
        var i = 0
        self.treesAray.append(tree);//æ·»åŠ æ ¹èŠ‚ç‚¹
        while true {
//ç›´åˆ°æ‰€æœ‰å­æ ‘éƒ½éå†å®Œæˆåˆ™é€€å‡º
            if i >= self.treesAray.count{break};
            let t = self.treesAray[i];
            if t.left != nil{//å¦‚æœæœ‰å·¦å­æ ‘å°±å…¥æ ˆ
                self.treesAray.append(t.left ?? Tree());
            }
            if t.right != nil{//å¦‚æœæœ‰å³å­æ ‘å°±å…¥æ ˆ
                self.treesAray.append(t.right ?? Tree());
            }
            i += 1;// éå†ä¸‹ä¸ªå­æ ‘
        }
    }
 

```
### Swiftç‰ˆæœ¬
```
//ä¸­åºéå†
    func travIn_C(tree:Tree?) -> Void {
        if tree == nil{
            return;
        }
        travIn_C(tree: tree?.left);
        self.valsArray.append(tree?.val ?? 0);
        travIn_C(tree: tree?.right);
    }




    //å…ˆåºéå†
    func travIn_L(tree:Tree?) -> Void {
        if tree == nil{
            return;
        }
        self.valsArray.append(tree?.val ?? 0);
        travIn_L(tree: tree?.left);
        travIn_L(tree: tree?.right);
    }
    //åç»­éå†
    func travIn_R(tree:Tree?) -> Void {
        if tree == nil{
            return;
        }
        travIn_R(tree: tree?.left);
        travIn_R(tree: tree?.right);
        self.valsArray.append(tree?.val ?? 0);
    }
```
### ***äºŒå‰æ ‘çš„è¿­ä»£å‰ä¸­ååºéå†***

![åŸäºŒå‰æ ‘](https://upload-images.jianshu.io/upload_images/783986-17b3456dc829b969.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
å‰åºéå†è¿­ä»£ï¼š
![å‰åºéå†è¿­ä»£](https://upload-images.jianshu.io/upload_images/783986-4df52486a08927d8.gif?imageMogr2/auto-orient/strip)

ä¸­åºéå†è¿­ä»£ï¼š
![ä¸­åºéå†è¿­ä»£](https://upload-images.jianshu.io/upload_images/783986-ab6088b6480745a7.gif?imageMogr2/auto-orient/strip)
![ååºéå†è¿­ä»£](https://upload-images.jianshu.io/upload_images/783986-a99bda46fe9b7b65.gif?imageMogr2/auto-orient/strip)
ï¼š

```
//å…ˆåºéå†
    func travIn_I_L(tree:Tree?) -> Void {
        if tree == nil{
            return;
        }
        var t = tree;
        while true {
            while t != nil {
                self.valsArray.append(t?.val ?? -1);
                if t?.right != nil{
                    self.treesAray.append(t?.right ?? Tree());
                }
                t = t?.left;
            }
            if self.treesAray.count == 0 {
                break;
            }
            t = self.treesAray.removeLast();
        }
    }

   //ä¸­åºéå†
    func travIn_I_C(tree:Tree?) -> Void {
        if tree == nil{
            return;
        }
        var t = tree;
        while true {
            while t != nil {
                self.treesAray.append(t ?? Tree());
                t = t?.left;
            }
            if self.treesAray.count == 0 {
                break;
            }
            t = self.treesAray.removeLast();
            self.valsArray.append(t?.val ?? -1);
            //æœ‰å³ç»“ç‚¹ åˆ™å‘å³ç§»åŠ¨ä¸€ä¸ªèŠ‚ç‚¹
            if t?.right != nil{
                t = t?.right;
            }else{//å¦åˆ™åˆ é™¤å·²ç»æ·»åŠ å¥½çš„ç»“ç‚¹
                t = nil;
            }
        }
    }


//åç»­éå†
    func travIn_I_R(tree:Tree?) -> Void {
        if tree == nil{
            return;
        }
        var t = tree;
        while true {
            while t != nil {
                self.treesAray.append(t ?? Tree());
                t = t?.left;
            }
            if self.treesAray.count == 0 {
                break;
            }
            t = self.treesAray.last;
            //æœ‰å³ç»“ç‚¹ åˆ™å‘å³ç§»åŠ¨ä¸€ä¸ªèŠ‚ç‚¹
            if t?.right != nil{
                t = t?.right;
            }else{//å¦åˆ™åˆ é™¤å·²ç»æ·»åŠ å¥½çš„ç»“ç‚¹
                self.valsArray.append(t?.val ?? -1);
                self.treesAray.removeLast();
                
                if self.treesAray.count > 0 {
                    let t1 = self.treesAray.last;
                    t1?.left = nil;
                    if t1?.right == t{//åˆ¤æ–­æ˜¯å¦æ˜¯å‘ä¸Šæ”€çˆ¬ YESåˆ™åˆ é™¤å³ç»“ç‚¹ï¼Œå¦åˆ™ä¸åˆ é™¤
                        t1?.right = nil;
                    }
                }
                t = nil;
            }
        }
    }


```


```
func isSymmetric(_ root: TreeNode?) -> Bool {
     // å±‚åºéå† æ ¡éªŒæ˜¯å¦æ˜¯ å¯¹ç§°æ ‘
        if  root == nil {
            return true;
        }
        var list :Array = [TreeNode]()
        if let val = root {
            list.append(val)
        }        
        while list.count > 0 {
            for index in 0...list.count/2 {
                let node1 = list[index]
                let node2 = list[list.count-index-1];
                if isSameTree2(node1, node2) == false {
                    return false;
                }
            }
            var subList:Array = [TreeNode]()
            var end:Int = 0 //ç»Ÿè®¡ç©ºèŠ‚ç‚¹
            
            for index in list {
                if let left = index.left {
                    subList.append(left)
                }else {
                    end += 1
                    let left = TreeNode(0);
                    subList.append(left);
                }
                if let right = index.right {
                    subList.append(right)
                }else {
                    end += 1
                    let left = TreeNode(0);
                    subList.append(left);
                }
            }
            if end == subList.count {
                subList.removeAll()
            }
            list.removeAll()
            list += subList
            subList.removeAll()
        }
        return true;
    }
//åˆ¤æ–­æ˜¯å¦æ˜¯ç›¸åŒçš„èŠ‚ç‚¹
    func isSameTree(_ left:TreeNode?,_ right:TreeNode?) -> Bool {
        if left == nil && right == nil {
            return true;
        }else  if left == nil && right != nil {
            return false
        }else if left != nil && right == nil {
            return false
        }else if let val1 = left?.val    {
                let val2 = right?.val
            if val1 == val2 {
                return true;
            }
        }
        return false;
    }
```


```
//æ„é€ èŠ‚ç‚¹
-(Node *)randNode{
    Node * node =[Node new];
    node.data = rand()%20 + 1;
    return node;
}

```
#### å…¶å®å¹³æ—¶éƒ½æ‹¿æ¥æ•°æ®æ˜¯æ•°ç»„å½¢å¼ï¼Œå¹¶ä¸èƒ½å¤Ÿç›´æ¥å½“åšäºŒå‰æ ‘ç›´æ¥æ¥æ“ä½œï¼Œéœ€è¦æŠŠæ•°ç»„è½¬åŒ–æˆäºŒå‰æ ‘ï¼Œé‚£ä¹ˆæ€ä¹ˆè½¬å‘¢ï¼Ÿ

åˆ©ç”¨äºŒå‰æ ‘çš„æ€§è´¨ï¼Œæ·±åº¦ä¸ºkçš„èŠ‚ç‚¹çš„å·¦å­æ ‘ä¸º`k*2+1`ï¼Œå³å­æ ‘ä¸º`k*2+2`ã€‚
é‚£ä¹ˆæ»¡äºŒå‰æ ‘èŠ‚ç‚¹æœ€å¤šä¸º`2^(k)-1`ï¼Œæœ€åä¸€å±‚å¶å­æœ€å¤šä¸º`2^(k-1)`ã€‚å¾—å‡ºæœ€åä¸€è¡Œçš„å¶å­çš„ç´¢å¼•ä¸º`2^(k-1)+1`ã€‚æ‰€ä»¥å‡è®¾æ•°ç»„æœ‰nä¸ªå…ƒç´ ï¼Œåˆ™æœ€åä¸€è¡Œå¶å­çš„ç´¢å¼•ä¸º`n/2-1`
å¾—å‡º ï¼š
```
func createTree() -> Tree? {
        self.vals = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15];
        
        self.top = createTreeWithArray(list: self.vals);
        return top;
    }
    func createTreeWithArray(list:[Int]) -> Tree {
        let length = list.count/2-1;
        
        var tArray:[Tree] = [Tree]();
        
        //ç”Ÿæˆæ•°ç»„ ğŸŒ²
        for i in 0..<list.count{
            let tsub = Tree.loadTree(val: list[i]);
            tArray.append(tsub);
        }
        //æ„é€ äºŒå‰æ ‘ğŸŒ²
        for i in 0..<length{
            let t :Tree = tArray[i];
            //æ„é€ å·¦å­©å­
            t.left = tArray[i*2+1];
            //æ„é€ å³å­©å­
            t.right = tArray[i*2+2];
        }
        //æ„é€ æœ€åä¸€ä¸ªåšå­©å­
        tArray[length].left = tArray[length*2+1];
        if length%2 == 1{//è‹¥æ•°ç»„ä¸ºå¥‡æ•°åˆ™å­˜åœ¨å³å­©å­
            tArray[length].right = tArray.last;
        }
        //è¿”å› topTree
        return tArray[0];
    }
```

[ç‚¹æˆ‘ä¸‹è½½ä»£ç ](https://github.com/ifgyong/leetCode)
